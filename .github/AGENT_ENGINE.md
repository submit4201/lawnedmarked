# Game Engine and Infrastructure Guide\n\nThe Game Engine is the orchestrator - it coordinates command dispatch, event persistence, and state reconstruction. The infrastructure components (registries, repository) are the factories and storage.\n\n## GameEngine Core\n\n**File:** `backend/engine/game_engine.py`\n\n```python\nclass GameEngine:\n    def __init__(\n        self,\n        event_repository: EventRepository,\n        action_registry: ActionRegistry,\n        event_registry: EventRegistry,\n        state_builder: StateBuilder,\n    ):\n        self.event_repository = event_repository\n        self.action_registry = action_registry\n        self.event_registry = event_registry\n        self.state_builder = state_builder\n```\n\n### Main Method: execute_command()\n\n```python\ndef execute_command(\n    self,\n    agent_id: str,\n    command: Command,\n) -> Tuple[bool, List[GameEvent], str]:\n    \"\"\"\n    Execute a player command.\n    \n    Returns: (success, events, message)\n    - success: True if command was validated and events emitted\n    - events: List of generated GameEvents (empty if failed)\n    - message: Status or error message\n    \"\"\"\n    # 1. Get current state\n    state = self.get_current_state(agent_id)\n    \n    # 2. Dispatch to handler via ActionRegistry\n    try:\n        events = self.action_registry.execute(state, command)\n    except DomainException as e:\n        return False, [], f\"Validation failed: {str(e)}\"\n    \n    # 3. Persist events\n    for event in events:\n        self.event_repository.save(event)\n    \n    # 4. Return success with generated events\n    return True, events, f\"Command {command.command_type} succeeded\"\n```\n\n**Flow diagram:**\n```\ncommand (e.g., TakeLoanCommand)\n    ↓\nget_current_state(agent_id)\n    ↓\naction_registry.execute(state, command)  ← Dispatches to handler\n    ├─ Valid: Returns List[GameEvent]\n    └─ Invalid: Raises DomainException\n    ↓\nFor each event: event_repository.save(event)\n    ↓\nReturn (success, events, message)\n```\n\n### State Retrieval: get_current_state()\n\n```python\ndef get_current_state(self, agent_id: str) -> AgentState:\n    \"\"\"\n    Reconstruct state by replaying event log.\n    \n    This is the ONLY way to get authoritative state.\n    State is never stored directly - always derived from events.\n    \"\"\"\n    # 1. Load all events from repository\n    events = self.event_repository.load_all()\n    \n    # 2. Filter to this agent only\n    agent_events = [e for e in events if e.agent_id == agent_id]\n    \n    # 3. Rebuild from events via StateBuilder\n    return self.state_builder.build_state(agent_events, agent_id=agent_id)\n```\n\n## Infrastructure: The Factories\n\n### ActionRegistry (Command → Handler Dispatcher)\n\n**File:** `backend/infrastructure/action_registry.py`\n\n**Purpose:** Maps command types to handler implementations (Factory Pattern)\n\n```python\nclass ActionRegistry:\n    def __init__(self):\n        self._handlers: Dict[str, Callable] = {}\n    \n    def register(self, command_type: str, handler: CommandHandler) -> None:\n        \"\"\"Register a handler for a command type.\"\"\"\n        self._handlers[command_type] = handler\n    \n    def execute(self, state: AgentState, command: Command) -> List[GameEvent]:\n        \"\"\"Dispatch command to registered handler.\"\"\"\n        handler = self._handlers[command.command_type]\n        return handler.handle(state, command)\n    \n    def get_registered_commands(self) -> List[str]:\n        \"\"\"List all registered command types.\"\"\"\n        return list(self._handlers.keys())\n```\n\n**Bootstrap example (in ApplicationFactory):**\n```python\naction_registry = ActionRegistry()\nfor command_type, handler in ALL_HANDLERS.items():\n    action_registry.register(command_type, handler)\n```\n\n### EventRegistry (Event → Projection Dispatcher)\n\n**File:** `backend/infrastructure/event_registry.py`\n\n**Purpose:** Maps event types to projection handlers (Factory Pattern)\n\n```python\nclass EventRegistry:\n    def __init__(self):\n        self._handlers: Dict[str, Callable[[AgentState, GameEvent], AgentState]] = {}\n    \n    def register(self, event_type: str, handler: Callable) -> None:\n        \"\"\"Register a projection handler for an event type.\"\"\"\n        self._handlers[event_type] = handler\n    \n    def apply(self, state: AgentState, event: GameEvent) -> AgentState:\n        \"\"\"Dispatch event to registered projection handler.\"\"\"\n        if event.event_type not in self._handlers:\n            raise NotImplementedError(\n                f\"No projection handler for {event.event_type}\"\n            )\n        handler = self._handlers[event.event_type]\n        return handler(state, event)\n    \n    def get_registered_events(self) -> List[str]:\n        \"\"\"List all registered event types.\"\"\"\n        return list(self._handlers.keys())\n```\n\n**Bootstrap example:**\n```python\nevent_registry = EventRegistry()\nfor event_type, handler in CORE_EVENT_HANDLERS.items():\n    event_registry.register(event_type, handler)\n```\n\n### EventRepository (Immutable Log)\n\n**File:** `backend/infrastructure/event_repository.py`\n\n**Purpose:** Append-only, immutable storage of all facts\n\n```python\nclass EventRepository(ABC):\n    @abstractmethod\n    def save(self, event: GameEvent) -> None:\n        \"\"\"Append event to log.\"\"\"\n        pass\n    \n    @abstractmethod\n    def load_all(self) -> List[GameEvent]:\n        \"\"\"Retrieve all events in chronological order.\"\"\"\n        pass\n\nclass InMemoryEventRepository(EventRepository):\n    \"\"\"In-memory implementation (for testing/demo).\"\"\"\n    def __init__(self):\n        self._events: List[GameEvent] = []\n    \n    def save(self, event: GameEvent) -> None:\n        self._events.append(event)\n    \n    def load_all(self) -> List[GameEvent]:\n        return self._events.copy()  # Return copy for safety\n```\n\n## StateBuilder: State Reconstruction Engine\n\n**File:** `backend/projection/state_builder.py`\n\n```python\nclass StateBuilder:\n    def __init__(self, event_registry: EventRegistry, initial_state: AgentState):\n        self.event_registry = event_registry\n        self.initial_state = initial_state  # Template for new agents\n    \n    def build_state(self, events: List[GameEvent], agent_id: str = None) -> AgentState:\n        \"\"\"\n        Reconstruct state by applying events sequentially.\n        \n        Args:\n            events: List of GameEvent in chronological order\n            agent_id: Optional agent_id to set on initial state\n        \n        Returns:\n            AgentState reflecting all applied events\n        \"\"\"\n        # 1. Start with template\n        state = deepcopy(self.initial_state)\n        if agent_id:\n            state.agent_id = agent_id\n        \n        # 2. Apply each event sequentially\n        for event in events:\n            state = self.event_registry.apply(state, event)\n        \n        # 3. Return final state\n        return state\n```\n\n**Why sequential application matters:**\n```\nInitial State: cash=10000, debt=0\n\nEvent 1: LoanTaken (principal=5000)\n  → Intermediate State: cash=10000, debt=5000\n\nEvent 2: FundsTransferred (amount=5000, type=LOAN)\n  → Final State: cash=15000, debt=5000\n\nOrder MUST be preserved - applying Event 2 before Event 1 gives wrong state!\n```\n\n## ApplicationFactory: Dependency Injection Bootstrap\n\n**File:** `backend/application_factory.py`\n\n```python\nclass ApplicationFactory:\n    @staticmethod\n    def create_game_engine() -> Tuple[GameEngine, GameMaster, Judge]:\n        \"\"\"\n        Create and wire all components.\n        \n        This is the ONLY place where all components are instantiated together.\n        Follows Dependency Injection pattern.\n        \"\"\"\n        # Create storage\n        event_repository = InMemoryEventRepository()\n        \n        # Create registries\n        action_registry = ActionRegistry()\n        event_registry = EventRegistry()\n        \n        # Register all handlers (from imports)\n        for command_type, handler in ALL_HANDLERS.items():\n            action_registry.register(command_type, handler)\n        \n        for event_type, handler in CORE_EVENT_HANDLERS.items():\n            event_registry.register(event_type, handler)\n        \n        # Create state builder\n        initial_state = AgentState(agent_id=\"TEMPLATE\")\n        state_builder = StateBuilder(event_registry, initial_state)\n        \n        # Create engine\n        game_engine = GameEngine(\n            event_repository=event_repository,\n            action_registry=action_registry,\n            event_registry=event_registry,\n            state_builder=state_builder,\n        )\n        \n        # Create adjudication subsystems\n        game_master = GameMaster(event_repository)\n        judge = Judge(event_repository)\n        \n        return game_engine, game_master, judge\n```\n\n**Usage:**\n```python\n# One-liner bootstrap\nengine, gm, judge = ApplicationFactory.create_game_engine()\n\n# Now engine is fully configured and ready to use\nstate = engine.get_current_state(\"PLAYER_001\")\n```\n\n## Command Dispatch Flow\n\n```\nPlayer Action: \"I want to set prices\"\n    ↓\nSetPriceCommand(agent_id=\"P1\", payload={location_id: \"LOC_001\", ...})\n    ↓\nGameEngine.execute_command(\"P1\", command)\n    ├─ state = get_current_state(\"P1\")\n    │  └─ StateBuilder rebuilds from events\n    │\n    ├─ events = action_registry.execute(state, command)\n    │  ├─ Lookup: _handlers[\"SET_PRICE\"] → SetPriceHandler()\n    │  ├─ Call: handler.handle(state, command)\n    │  │  ├─ Validate: location exists?\n    │  │  ├─ Compute: new_price\n    │  │  └─ Emit: [PriceSet(...)]  or raise InsufficientFundsError\n    │  └─ Return: [PriceSet(...)]\n    │\n    ├─ For each event: event_repository.save(event)\n    │  └─ Append to immutable log\n    │\n    └─ Return: (True, [PriceSet(...)], \"Command succeeded\")\n```\n\n## State Reconstruction Flow\n\n```\nGameEngine.get_current_state(\"P1\")\n    ↓\nevent_repository.load_all()\n    ├─ Returns: [TimeAdvanced, LoanTaken, FundsTransferred, ...]\n    │\n    └─ Filter by agent_id: [LoanTaken(agent_id=\"P1\"), FundsTransferred(agent_id=\"P1\")]\n       ↓\n       StateBuilder.build_state(agent_events, agent_id=\"P1\")\n       ├─ state = AgentState(agent_id=\"P1\")  [initial]\n       ├─ state = registry.apply(state, LoanTaken(...))\n       │  ├─ Look up: _handlers[\"LoanTaken\"]\n       │  ├─ Call: handle_loan_taken(state, event)\n       │  └─ Return: modified state\n       ├─ state = registry.apply(state, FundsTransferred(...))\n       │  └─ Call: handle_funds_transferred(state, event)\n       └─ Return: final state with all events applied\n```\n\n## Testing the Engine\n\n```python\nfrom application_factory import ApplicationFactory\n\n# Bootstrap\nengine, _, _ = ApplicationFactory.create_game_engine()\n\n# Execute command\ncommand = TakeLoanCommand(\n    agent_id=\"TEST_001\",\n    payload={\"principal\": 5000, \"interest_rate\": 0.05, \"term_weeks\": 26}\n)\n\nsuccess, events, message = engine.execute_command(\"TEST_001\", command)\n\n# Verify\nassert success == True\nassert len(events) == 2  # LoanTaken + FundsTransferred\nassert events[0].event_type == \"LoanTaken\"\nassert events[1].event_type == \"FundsTransferred\"\n\n# Verify state reconstruction\nstate = engine.get_current_state(\"TEST_001\")\nassert state.total_debt_owed == 5000\nassert state.cash_balance == 15000  # 10000 + 5000 loan\n\n# Verify event log\nlog = engine.get_event_log(\"TEST_001\")\nassert len(log) == 2\n```\n\n## Adding Custom CommandHandlers and EventHandlers\n\n**Does NOT require modifying GameEngine, ActionRegistry, or EventRegistry!**\n\n### To add new command:\n1. Define in `core/commands.py`\n2. Create handler in `command_handlers/my_handlers.py`\n3. Export in `command_handlers/__init__.py` → `ALL_HANDLERS`\n4. ApplicationFactory auto-discovers\n\n### To add new event:\n1. Define in `core/events.py`\n2. Create handler in `projection/handlers/core_handlers.py`\n3. Register in `CORE_EVENT_HANDLERS` dict\n4. ApplicationFactory auto-discovers\n\n**No GameEngine changes ever needed** - the registries provide the extension points (Open/Closed Principle).\n"