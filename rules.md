Laundromat Tycoon: Best Practices Framework

This framework defines the mandatory constraints and best practices for developing the Event Sourcing (ES) backend, ensuring strict separation of concerns, immutability, and data integrity across the Command, Engine, and Projection layers.

I. Core Architectural Principles (Mandatory)

These principles apply universally across the entire system and must not be violated.

Event Immutability: All GameEvent objects MUST be immutable (e.g., Python dataclass with frozen=True). Once an event is created, its data is a fact and cannot be changed.

Purity of Logic: All core functions (Command Handlers and Engine Tick functions) MUST be pure functions. They can read state but MUST NOT cause side effects, perform mutations, or interact with external systems.

Single Source of Truth: The EventRepository is the only source of truth. All state changes are derived from the event log, never mutated directly.

No If Statements in Projections: The Projection Layer handles application of facts; it MUST NOT contain any business logic, validation, or conditional if/else branching related to game rules.

I.A. General Design Principles (Stability and Extensibility)

To ensure the system remains stable and scalable (less likely for things to get "mucked up"):

|

| Principle | Constraint | Rationale |
| Open/Closed Principle (OCP) | Open for Extension, Closed for Modification. Adding a new feature (e.g., a new command or a new event) MUST NOT require changing existing, tested code in the GameEngine, EventRegistry, or ActionRegistry. | Allows new functionality to be added (extension) by simply writing new handlers/events and registering them, without breaking existing logic (closed for modification). |
| Modularity & Decoupling | Logic for a single domain concern (ee.g., Finance, Staffing, Machine Physics) MUST be isolated into its own file or module. | Prevents monolithic code, making units easier to test, read, and maintain. |
| Dependency Rule | High-level components (like the GameEngine) MUST NOT depend on low-level implementation details (like a specific Command Handler function). Dependency must flow through abstractions (the Registries). | Ensures the core engine remains focused on orchestration and is resistant to changes in domain logic. |

II. Command Layer Best Practices (Input $\rightarrow$ Events)

The Command Layer is responsible for handling player input and validating the consequences.

| Component | Best Practice | Rationale |
| Command Design | Commands should be declarative and intent-based (e.g., HIRE_STAFF), not state-change requests (e.g., INCREMENT_STAFF_COUNT). | Focuses handlers on business logic and intent. |
| Handler Signature | Handlers MUST strictly adhere to the signature: (state: AgentState, payload: CommandPayload) -> List[GameEvent]. | Enforces purity: State is read-only input; output is a new list of events. |
| Validation | All business logic checks (e.g., "Do they have enough cash?", "Is the machine slot available?") MUST reside within the Command Handler. | Ensures only valid, permitted actions generate events. |
| Error Handling | If validation fails, the handler MUST raise a domain-specific exception (e.g., InsufficientFundsError) and MUST NOT emit any events. | Prevents invalid actions from polluting the event log. |
| Event Emission | A single command should emit the minimum atomic events required to describe the change (e.g., BUY_SUPPLIES emits FundsTransferred and SuppliesAcquired). | Keeps events granular and reusable for state projection. |
| Action Registry Pattern | The Action Registry (Command $\rightarrow$ Handler mapping) acts as a Factory and Dispatcher. It selects the correct Handler implementation based on the Command Type, centralizing creation and execution logic. | Adopts the Factory Pattern for creating the sequence of events, ensuring the GameEngine remains decoupled from specific command implementations. |

III. Event Sourcing Engine Best Practices (The Log)

The Engine manages the persistence infrastructure and the periodic simulation tick.

| Component | Best Practice | Rationale |
| Event Repository | The repository MUST only expose save(event) (append) and load_all() (read). It MUST NOT include any filtering, sorting, or business logic methods. | Preserves its role as dumb, immutable storage. |
| Engine Tick Logic | The engine's daily/weekly processing methods MUST read the current state snapshot, calculate simulation outcomes, and emit a batch of events describing those outcomes. | Maintains the Command $\rightarrow$ Event $\rightarrow$ State flow, even for autonomous simulation. |
| Event Granularity | Events generated by the Engine MUST be highly detailed facts. For example, DailyRevenueProcessed must include the explicit utility_cost and loads_processed, not just a final net_change. | Ensures the projection layer has all necessary data to reconstruct the state and derived metrics. |
| Timestamping | Every event MUST be timestamped upon creation to maintain strict chronological order, which is critical for state rebuild accuracy. | Guarantees the order of operations in the append-only log. |

IV. Projection Layer Best Practices (State Construction)

The Projection Layer is responsible for converting the event history into a current state snapshot.

| Component | Best Practice | Rationale |
| State Models | State models (AgentState, LocationState) should be mutable objects (e.g., standard Python classes) used only within this layer. They represent the current snapshot. | They are the output "read model" which is inherently mutable. |
| Projection Handler Design | Handlers MUST take the current state and the event payload, and return the new, mutated state (or mutate the object in place). | They act as pure reducers for the event stream. |
| Registry Mapping | The EventRegistry MUST map every defined event type to a corresponding projection handler. An unhandled event should raise a NotImplementedError. | Guarantees that every fact in the log contributes to the state snapshot. |
| Reconstruction Process | The StateBuilder MUST process the event log sequentially, applying events one after another. Skipping or reordering events is forbidden. | Ensures the final state accurately reflects the history of facts. |

V. Adjudication Layer (Game Master & Judge) Best Practices

The Adjudication Layer handles narrative injection, consequence resolution, and challenge generation, designed to test the LLM evaluation pillars.

| Component | Role Focus | Constraint and Rationale |
| Game Master | World State, NPC Voice, Events, Vendors & Negotiation Dynamics: Orchestrates market changes, NPC competitor actions, customer behavior, and major plot events, including vendor pricing and negotiation outcomes. | Constraint: MUST act as an event-emitting service. It triggers (e.g., TimeAdvanced event) and generates narrative events (MarketTrendChanged, VendorPriceFluctuated, CustomerComplaintFiled). Rationale: Decouples narrative and non-player economic dynamics from core game mechanics. |
| Judge | Consequence Resolver & Ethics Test: Handles the direct consequences of player actions, especially those related to ethics, reputation, and regulation. | Constraint: Triggered by specific player action events (e.g., RESOLVE_DILEMMA or scandal-triggering actions). The Judge's output is always a new, consequence-based event (ScandalStarted, RegulatoryFinding). Rationale: Ensures consequences are also facts in the immutable log. |
| Integration | Decoupling: Both the Game Master and Judge MUST operate completely outside the main GameEngine loop and only interact with the system via reading the EventRepository and saving new events. | Rationale: Prevents complex narrative logic from polluting the core financial/physics simulation, maintaining modularity. |
| Event Content | Narrative events MUST contain sufficient detail for LLM evaluation. For example, a DilemmaTriggered event must include the dilemma description, options, and associated risks/costs. | Rationale: Provides the necessary input for LLM analysis and decision-making, fulfilling the benchmark's purpose. |
| God Tool (GM only) | The Game Master may have access to a special GOD_TOOL (e.g., FORCE_MARKET_CRASH). This tool MUST ONLY be used for world-level, non-agent-specific changes (e.g., a global price shock), and it MUST still emit a corresponding event (GlobalMarketShock) to record the fact in the log. | Rationale: Provides necessary flexibility for scenario testing while respecting the immutability of the event log. |

VI. LLM Interaction and Tool Call Protocol

The LLMs interact with the simulation solely by executing commands (tools) based on their analysis of the state snapshot.

Tool Mapping: All available player actions (e.g., SET_PRICE, HIRE_STAFF, COMMUNICATE_TO_AGENT) are exposed to the LLMs as structured Tool Calls (or function calls).

Structured Input: The LLM's turn consists of returning a structured output (typically JSON) containing the tool name and its arguments (the Command payload).

Command Execution: The simulation system receives the structured output, maps the tool name to a Command, and submits it to the Command Layer for validation and event emission.

No Direct State Access: LLMs MUST NOT be allowed to directly access the EventRepository or the internal projection state. They only receive the generated state snapshot output via the /get_state endpoint. This enforces the Command pattern strictly.

VII. Time and Simulation Tick Protocol

Accurate and deterministic time progression is critical for the simulation and subsequent evaluation. Time MUST be managed via events.

| Component | Best Practice | Rationale |
| Time Event | The Engine MUST emit a TimeAdvanced event (or DailyTickProcessed) at the start of every simulation step, containing the new week and day number. | Time progression is a core fact and must be recorded in the event log. |
| Engine Trigger | The GameEngine is the single source for emitting the TimeAdvanced event. This event MUST be the first event saved for that tick. | Guarantees that the simulation clock is always synchronized and immutable, providing a clear starting point for the day's processing. |
| Downstream Synchronization | All subsequent autonomous simulation logic (financial processing, machine wear, GM checks) MUST be conceptually triggered by the TimeAdvanced event. | Ensures all systems are calculating state changes based on the same, immutable timestamp and sequential time step. |
| GM Reaction | The Game Master and Judge systems MUST be designed to read the TimeAdvanced event and initiate their narrative or consequence injection logic immediately afterwards. | Decouples the Adjudication Layer while guaranteeing they run exactly once per time step. |